# c++ 基础类型

## sizeof
sizeof是操作符，即它并不是函数，它的作用对象是数据类型，因此，它作用于变量时，也是对其类型进行操作。得到的结果是该数据类型占用空间大小，即size_t类型。  

## strlen
用于计算字符串的长度。它的计算原则是：

从参数s所指向的内存开始往后计数，直到内存中的内容是 '\0'（表示空字符）.

常量字符串末尾会 置为 '\0'，以表示字符串结束。

## 如何区分
可以将字符串转为字符数组来观察，可能更为清晰。

    例1：
        char str[] = "hello";
        printf(sizeof(str), strlen(str)); //6 5  
    字符串常量"hello"实际是 {'h','e','l','l','o','\0'} , 整个字符数组实际有6位，最后一位为 空字符，所以sizeof 为6， strlen不记录 '\0'位，所以是5.

    例2：
        char str2[] = {'h','e','l','l','o'};
        printf(sizeof(str2), strlen(str2)); //5 10
    此时字符数组大小是5，但是 '\0'不知道在什么位置，所以strlen可能奔溃或任何值。


    例3：
        char *str3 = "hello";//最后有一个”隐形“的'0'
        printf(sizeof(str3), strlen(str3)); //8 5
    str3不是一个数组，而是一个字符指针，64位程序中，它的大小就是8。后者还是从str3指向的地址开始，直到遇到 '\0'，即得到长度5。

    例4：
        void testArr(const char str[])
        {
            printf(sizeof(str), strlen(str));
        }
        char str4[] = "hello";
        testArr(str4);//8 5
    当数组作为参数时，实际上只是一个指针，所以用sizeof计算时，会得到8。

    例5：
        char str5[] = "hell0o";
        printf(sizeof(str5), strlen(str5)); //7 4
    sizeof没啥好说的，str5等价于{'h','e'.'l','l','\0','o','\0'},strlen是4也没毛病。

    例6：
        char str7[5] = "hello";
        printf("test7 %lu %lunn", sizeof(str7), strlen(str7)); //5 10
    这是非常危险的，声明了占用空间是5，它没有空间容纳最后的'\0'，因此导致strlen计算的结果和test2一样，可能会是任意值。