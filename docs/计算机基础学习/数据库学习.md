# 数据库学习总结
面试问题汇总： https://leetcode-cn.com/circle/discuss/6xECGC/
## 关系数据库

### 键
* 超键，一个或多个属性的组合，通过超键可以在一个关系中唯一的标识一个元组。
* 候选键，最小超键，其任意真子集都不能成为超键
* 主键，是一个候选键

### 外键
现有一个班级表和学生表，班级表指示了班级的id、班号等信息，学生表是所有学生相关信息的表。
班级表如下图：
| id     | name     | other column |
| :------: | :------: | :------:|
| 0        | 一班     | ···         |
| 1        | 二班     | ···         |
| ···        | ···     |···        |

学生表如下图：
| id     | name     | other column |
| :------: | :------: | :------:|
| 0        | 小明     | ···         |
| 1        | 小王     | ···         |
| ···        | ···     |···        |

现在的问题在于如何确定某个学生是几班的？这种关系是一对多的，即一个班级的记录可以对应多条学生记录。为了表达这种一对多的关系，我们需要在学生表中加入一列 class_id ，让它的值与班级表的某条记录相对应：
| id     |class_id| name     | other column |
| :------: | :------: | :------:| :------:|
| 0        |1| 小明     | ···         |
| 1        |1| 小王     | ···         |
| 1        |2| 小白     | ···         |
| ···        | ···     |···        |

这样，我们就可以根据class_id这个列直接定位出一个students表的记录应该对应到班级表的哪条记录。  

在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键。  

外键并不是通过列名实现的，而是通过定义外键约束实现的：  

    ALTER TABLE students
    ADD CONSTRAINT fk_class_id
    FOREIGN KEY (class_id)
    REFERENCES classes (id);

其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。
## SQL （Structured Query Language，结构化查询语言）


## 索引
### 索引类型：  
* 顺序索引：基于值的顺序排序
* 散列索引：基于散列函数将值分到若干桶里  

索引结构与一个特定的搜索键相关联。  
具体的一个索引项由一个搜索键值和指向该索引值的一条或多条记录的指针组成。

### 搜索键（search key）
用于在文件中查找记录的属性和属性集称为搜索键。


### 顺序索引（索引项中的搜索键是顺序的）
顺序索引按照顺序存放搜索码的值，即索引项中的搜索键码值是按照顺序存放的。但是在对应的数据库文件中，记录可能按照与搜索键值同样的顺序存放（主索引），也可能具有不同的顺序（辅助索引）。


* 聚集索引（主索引）：包含记录的文件按照搜索键排序（主索引的搜索键通常为主键，但是实际上它可以建立在任意搜索键上）  
  
    聚集索引由于搜索键按照顺序存放于存储空间，因此我们可以实现顺序访问和随机访问（随机访问通过首地址+偏移量 实现）

  * 稠密索引：每个搜索键值都有一个索引项。索引项包括搜索键值以及指向具有该搜索键值的第一条数据记录的指针。
  
  * 稀疏索引：只为搜索键的某些值设置索引项。查找一条记录时，从小于等于该记录的搜索键值的索引项开始顺序查找。
  
    ![](../../pictures/稠密索引和稀疏索引示意图.png)

* 非聚集索引（辅助索引）：搜索键的顺序和文件的数据顺序不同。  
    辅助索引必须是稠密索引。原因是如果采用稀疏索引，两个有索引项的搜索码值之间的记录可能存在于文件任何位置。

    　在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值（候选键）。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。

    而对于稠密索引而言，我们也分两种情况，索引键是候选键或不是候选键。对于搜索键是候选键的情况而言，直接采用稠密索引的方式即可解决；对于搜索键是非候选键而言，需要使用一个附加的间接指针层，中间层采用一个候选键。

### 散列索引
基于HASH技术，可以避免我们去访问过多的索引。  
* 静态散列   
  hash函数固定，但随着数据增大，同一个hash对应下的数据量可能巨大

* 动态散列
通过桶的分裂或者合并，来适应数据库大小的变化。

## B+树索引
本质上是多级索引。
![](/pictures/二级稀疏索引.png)

叶子节点上存放数据库文件信息，非叶子节点上存放索引。

B+树 对比 B树：  

* b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；
* b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；
* 对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历。

除数据库外，还有文件系统的索引也用到了B+树。

## 前缀索引 和 覆盖索引
数据库变大之后，索引也会变长，前缀索引即只使用正常索引的一部分作为索引项。  
覆盖索引即索引项包含了数据库的数据。



## 三大范式

1、所有字段值都是不可分解的原子值  
比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式。  
2、一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。  
比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。  
![](../../pictures/数据库第二范式图例.png)  
3、每一列数据都和主键直接相关，而不能间接相关。



## 隔离级别

1、READ UNCOMMITTED （未提交读）

　　在 READ UNCOMMITTED 级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read)。这个级别会导致很多问题，从性能上来说，READ UNCOMMITTED 不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。

2、READ COMMITTED （提交读）

　　大多数数据库系统的默认级别都是 READ COMMITTED（但 MySQL 不是）。READ COMMITTED 满足前面提到的隔离性的简单定义：一个事务开始时，只能“看到”已经提交的事物所做的修改。换句话说，一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读（nonrepeatable read），因为两次执行相同的查询，可能会得到不一样的结果。

发生幻读：其他事务在某事物开始之前和提交之后进行读取，所获取到的数据不一致。

3、REPEATABLE READ (可重复读）

　　REPETABLE READ 解决了脏读的问题。该级别保证了在同一个事物中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read) 的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。InnoDB 和 XtraDB 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control) 解决了幻读的问题。可重复读是MySQL的默认事务隔离级别。

4、SERIALIZABLE （可串行化）

　　SERIALIZABLE 是最高的隔离界别。它通过强制事务串行执行，避免了前面所说的幻读的问题。简单来说，SERIALIZABLE会再读取的每一行数据上都加锁，所有可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别，只有在非常需要保证数据的一致性而且接受没有并发的情况下，才考虑采用该级别。